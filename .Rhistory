all_cats_entropy_copp_weighted_plot <- tm_shape(ham_bay, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0) +
tm_shape(hydro_p_LakeOntario, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0)+
tm_shape(all_cats) +
tm_polygons("entropy_copp_isc_medsd_w",
border.alpha = 0.2,
palette = "reds", style="quartile", n=4,
title = "Diversity of (all - weighted) care destinations spatially accessible within 15 min. walk",
legend.is.portrait = TRUE) +
tm_shape(Community_Boundaries) + tm_polygons(alpha=0)+
tm_scale_bar(position = c("left", "bottom"), breaks = c(0, 1, 5, 10, 15)) +
tm_compass(position = c("right", "top"), size=1.0)+
tm_layout(bg.color = "grey",
panel.label.bg.color = "white",
panel.label.color = "black",
legend.outside = TRUE,
legend.position = c("center", "bottom"),
legend.outside.position = "bottom",
legend.outside.size = 0.2,
legend.width = 12)
tmap_save(all_cats_entropy_copp_weighted_plot, file="all_cats_entropy_copp_weighted_plot.tiff")
all_cats_entropy_copp_weighted_plot <- tm_shape(ham_bay, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0) +
tm_shape(hydro_p_LakeOntario, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0)+
tm_shape(all_cats) +
tm_polygons("entropy_copp_isc_medsd_w",
border.alpha = 0.2,
palette = "reds", style="quantile", n=4,
title = "Diversity of (all - weighted) care destinations spatially accessible within 15 min. walk",
legend.is.portrait = TRUE) +
tm_shape(Community_Boundaries) + tm_polygons(alpha=0)+
tm_scale_bar(position = c("left", "bottom"), breaks = c(0, 1, 5, 10, 15)) +
tm_compass(position = c("right", "top"), size=1.0)+
tm_layout(bg.color = "grey",
panel.label.bg.color = "white",
panel.label.color = "black",
legend.outside = TRUE,
legend.position = c("center", "bottom"),
legend.outside.position = "bottom",
legend.outside.size = 0.2,
legend.width = 12)
tmap_save(all_cats_entropy_copp_weighted_plot, file="all_cats_entropy_copp_weighted_plot.tiff")
all_cats_entropy_copp_weighted_plot <- tm_shape(ham_bay, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0) +
tm_shape(hydro_p_LakeOntario, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0)+
tm_shape(all_cats) +
tm_polygons("entropy_copp_isc_medsd_w",
border.alpha = 0.2,
palette = "Reds", style="quantile", n=4,
title = "Diversity of (all - weighted) care destinations spatially accessible within 15 min. walk",
legend.is.portrait = TRUE) +
tm_shape(Community_Boundaries) + tm_polygons(alpha=0)+
tm_scale_bar(position = c("left", "bottom"), breaks = c(0, 1, 5, 10, 15)) +
tm_compass(position = c("right", "top"), size=1.0)+
tm_layout(bg.color = "grey",
panel.label.bg.color = "white",
panel.label.color = "black",
legend.outside = TRUE,
legend.position = c("center", "bottom"),
legend.outside.position = "bottom",
legend.outside.size = 0.2,
legend.width = 12)
tmap_save(all_cats_entropy_copp_weighted_plot, file="all_cats_entropy_copp_weighted_plot.tiff")
400*3
tmap_save(pop_descriptive_plots, file="pop_descriptive_plots.tiff", asp = 1/2)
parcels_DA_plot <-
tm_shape(ham_bay, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0) +
tm_shape(hydro_p_LakeOntario, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0)+
tm_shape(access_15_DA) +
tm_polygons("parcel_count",
border.alpha = 0.2,
palette = "Reds",style = "quantile", n=4,
title = "Count of residential parcels",
legend.is.portrait = TRUE) +
tm_shape(Community_Boundaries) + tm_polygons(alpha=0)+
tm_scale_bar(position = c("left", "bottom"), breaks = c(0, 1, 5, 10, 15)) +
tm_compass(position = c("left", "top"), size=1.0)+
tm_layout(bg.color = "grey", panel.label.bg.color = "white", legend.position = c("right", "top"), legend.text.size = 0.5, legend.bg.color = "white", legend.bg.alpha = 0.4)
poprate_DA_plot <-
tm_shape(ham_bay, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0) +
tm_shape(hydro_p_LakeOntario, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0)+
tm_shape(access_15_DA |> mutate(popden = Population/Dwellings)) +
tm_polygons("popden",
border.alpha = 0.2,
palette = "Purples", style = "quantile", n=4,
title = "Population per dwelling",
legend.is.portrait = TRUE) +
tm_shape(Community_Boundaries) + tm_polygons(alpha=0)+
tm_scale_bar(position = c("left", "bottom"), breaks = c(0, 1, 5, 10, 15)) +
tm_compass(position = c("left", "top"), size=1.0)+
tm_layout(bg.color = "grey", panel.label.bg.color = "white", legend.position = c("right", "top"), legend.text.size = 0.5, legend.bg.color = "white", legend.bg.alpha = 0.4)
LICOAT_DA_plot <-
tm_shape(ham_bay, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0) +
tm_shape(hydro_p_LakeOntario, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0)+
tm_shape(access_15_DA) +
tm_polygons("LICO_AT_TOTAL",
border.alpha = 0.2,
palette = "Oranges", style = "quantile", n=4,
title = "Prevalance of household LICO-AT",
legend.is.portrait = TRUE) +
tm_shape(Community_Boundaries) + tm_polygons(alpha=0)+
tm_scale_bar(position = c("left", "bottom"), breaks = c(0, 1, 5, 10, 15)) +
tm_compass(position = c("left", "top"), size=1.0)+
tm_layout(bg.color = "grey", panel.label.bg.color = "white", legend.position = c("right", "top"), legend.text.size = 0.5, legend.bg.color = "white", legend.bg.alpha = 0.4)
pop_descriptive_plots <- tmap_arrange(parcels_DA_plot, poprate_DA_plot, LICOAT_DA_plot, nrow=3)
tmap_save(pop_descriptive_plots, file="pop_descriptive_plots.tiff", asp = 1/2)
tmap_save(pop_descriptive_plots, file="pop_descriptive_plots.tiff", asp = 1/1.5)
tmap_save(pop_descriptive_plots, file="pop_descriptive_plots.tiff", asp = 1/1.1)
tmap_save(pop_descriptive_plots, file="pop_descriptive_plots.tiff", asp = 1/0.9)
tmap_save(pop_descriptive_plots, file="pop_descriptive_plots.tiff", asp = 1/0.7)
tmap_save(pop_descriptive_plots, file="pop_descriptive_plots.tiff", asp = 1/0.6)
tmap_save(pop_descriptive_plots, file="pop_descriptive_plots.tiff", asp = 1/0.5)
LICOAT_DA_plot <-
tm_shape(ham_bay, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0) +
tm_shape(hydro_p_LakeOntario, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0)+
tm_shape(access_15_DA) +
tm_polygons("LICO_AT_TOTAL",
border.alpha = 0.2,
palette = "Oranges", style = "quantile", n=4,
title = "Prevalance of household LICO-AT",
legend.is.portrait = TRUE) +
tm_shape(Community_Boundaries) + tm_polygons(alpha=0)+
tm_scale_bar(position = c("left", "bottom"), breaks = c(0, 1, 5, 10, 15)) +
tm_compass(position = c("left", "top"), size=1.0)+
tm_layout(bg.color = "grey", panel.label.bg.color = "white", legend.position = c("right", "top"), legend.text.size = 0.5, legend.title.size = 0.7, legend.bg.color = "white", legend.bg.alpha = 0.4)
parcels_DA_plot <-
tm_shape(ham_bay, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0) +
tm_shape(hydro_p_LakeOntario, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0)+
tm_shape(access_15_DA) +
tm_polygons("parcel_count",
border.alpha = 0.2,
palette = "Reds",style = "quantile", n=4,
title = "Count of residential parcels",
legend.is.portrait = TRUE) +
tm_shape(Community_Boundaries) + tm_polygons(alpha=0)+
tm_scale_bar(position = c("left", "bottom"), breaks = c(0, 1, 5, 10, 15)) +
tm_compass(position = c("left", "top"), size=1.0)+
tm_layout(bg.color = "grey", panel.label.bg.color = "white", legend.position = c("right", "top"), legend.text.size = 0.5,legend.title.size = 0.7,  legend.bg.color = "white", legend.bg.alpha = 0.4)
poprate_DA_plot <-
tm_shape(ham_bay, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0) +
tm_shape(hydro_p_LakeOntario, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0)+
tm_shape(access_15_DA |> mutate(popden = Population/Dwellings)) +
tm_polygons("popden",
border.alpha = 0.2,
palette = "Purples", style = "quantile", n=4,
title = "Population per dwelling",
legend.is.portrait = TRUE) +
tm_shape(Community_Boundaries) + tm_polygons(alpha=0)+
tm_scale_bar(position = c("left", "bottom"), breaks = c(0, 1, 5, 10, 15)) +
tm_compass(position = c("left", "top"), size=1.0)+
tm_layout(bg.color = "grey", panel.label.bg.color = "white", legend.position = c("right", "top"), legend.text.size = 0.5,legend.title.size = 0.7,  legend.bg.color = "white", legend.bg.alpha = 0.4)
LICOAT_DA_plot <-
tm_shape(ham_bay, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0) +
tm_shape(hydro_p_LakeOntario, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0)+
tm_shape(access_15_DA) +
tm_polygons("LICO_AT_TOTAL",
border.alpha = 0.2,
palette = "Oranges", style = "quantile", n=4,
title = "Prevalance of household LICO-AT",
legend.is.portrait = TRUE) +
tm_shape(Community_Boundaries) + tm_polygons(alpha=0)+
tm_scale_bar(position = c("left", "bottom"), breaks = c(0, 1, 5, 10, 15)) +
tm_compass(position = c("left", "top"), size=1.0)+
tm_layout(bg.color = "grey", panel.label.bg.color = "white", legend.position = c("right", "top"), legend.text.size = 0.5, legend.title.size = 0.7, legend.bg.color = "white", legend.bg.alpha = 0.4)
pop_descriptive_plots <- tmap_arrange(parcels_DA_plot, poprate_DA_plot, LICOAT_DA_plot, nrow=3)
pop_descriptive_plots
tmap_save(pop_descriptive_plots, file="pop_descriptive_plots.tiff", asp = 1/0.5)
tmap_save(pop_descriptive_plots, file="pop_descriptive_plots.tiff", asp = 1/0.8)
tmap_save(pop_descriptive_plots, file="pop_descriptive_plots.tiff", asp = 1/0.6)
all_cats_entropy_copp_plot <- tm_shape(ham_bay, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0) +
tm_shape(hydro_p_LakeOntario, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0)+
tm_shape(all_cats) +
tm_polygons("entropy_copp_isc_medsd",
border.alpha = 0.2,
palette = "Reds",
title = "Diversity of (all) care destinations spatially accessible within 15 min. walk",
legend.is.portrait = TRUE) +
tm_shape(Community_Boundaries) + tm_polygons(alpha=0)+
tm_scale_bar(position = c("left", "bottom"), breaks = c(0, 1, 5, 10, 15)) +
tm_compass(position = c("right", "top"), size=1.0)+
tm_layout(bg.color = "grey",
panel.label.bg.color = "white",
panel.label.color = "black",
legend.outside = TRUE,
legend.position = c("center", "bottom"),
legend.outside.position = "bottom",
legend.outside.size = 0.2,
legend.width = 12)
tmap_save(all_cats_entropy_copp_plot, file="all_cats_entropy_copp_plot.tiff")
all_cats_entropy_copp_weighted_plot <- tm_shape(ham_bay, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0) +
tm_shape(hydro_p_LakeOntario, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0)+
tm_shape(all_cats) +
tm_polygons("entropy_copp_isc_medsd_w",
border.alpha = 0.2,
palette = "Reds",
title = "Diversity of (all - weighted) care destinations spatially accessible within 15 min. walk",
legend.is.portrait = TRUE) +
tm_shape(Community_Boundaries) + tm_polygons(alpha=0)+
tm_scale_bar(position = c("left", "bottom"), breaks = c(0, 1, 5, 10, 15)) +
tm_compass(position = c("right", "top"), size=1.0)+
tm_layout(bg.color = "grey",
panel.label.bg.color = "white",
panel.label.color = "black",
legend.outside = TRUE,
legend.position = c("center", "bottom"),
legend.outside.position = "bottom",
legend.outside.size = 0.2,
legend.width = 12)
tmap_save(all_cats_entropy_copp_weighted_plot, file="all_cats_entropy_copp_weighted_plot.tiff")
all_cats_bivariate_entropy_copp_plot <- tm_shape(ham_bay, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0) +
tm_shape(hydro_p_LakeOntario, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0)+
tm_shape(all_cats) +
tm_polygons("bivariate_entropy_w",
border.alpha = 0.2,
palette = c("yellowgreen","yellow","blue", "#FFFFDF"),
title = "Diversity of (all - weighted) care destinations spatially accessible within 15 min. walk",
legend.is.portrait = TRUE) +
tm_shape(Community_Boundaries) + tm_polygons(alpha=0)+
tm_scale_bar(position = c("left", "bottom"), breaks = c(0, 1, 5, 10, 15)) +
tm_compass(position = c("right", "top"), size=1.0)+
tm_layout(bg.color = "grey",
panel.label.bg.color = "white",
panel.label.color = "black",
legend.outside = TRUE,
legend.position = c("center", "bottom"),
legend.outside.position = "bottom",
legend.outside.size = 0.2,
legend.width = 12)
tmap_save(all_cats_bivariate_entropy_copp_plot, file="all_cats_bivariate_entropy_copp_plot.tiff")
word_comment("AS NOTE: thoughts on this?", "weighted to equal")
paste0('[', comment, ']{.comment-start id="0" author="Anastasia"',
'date="2023-08-12T15:00:00Z"}', highlight, '[]{.comment-end id="0"}')
#function for creating comments
word_comment <- function(comment, highlight = "") {
if (isTRUE(knitr:::pandoc_to() == "docx")) {
paste0('[', comment, ']{.comment-start id="0" author="Anastasia"',
'date="2023-08-12T15:00:00Z"}', highlight, '[]{.comment-end id="0"}')
}
}
word_comment("AS NOTE: thoughts on this?", "weighted to equal")
word_comment("AS NOTE: thoughts on this choice? I think we need to consider both the category type and the specific type in this paper. We justify the categories so that's fair but I still think there's value in presenting the specific type  some how - this is what I think this diversity index is good for so I've presented that as an option. Note though, it'd be much more simple to just focus on calculating the $D^{st}_{DA}$ using the $S_i^c$ and not introducing the $S_i^{st}$ calculation like I've done.. so I've made the analysis more complicated. Also destination weighting is based on the four categories - so that is distorting the diversity in certain ways.",".")
library(tidyverse) # Easily Install and Load the 'Tidyverse'
library(plotly) # Create Interactive Web Graphics via 'plotly.js'
no <- 75
y <- 4 * runif(no, min = 0, max = 0.2)
z <- 1 - y + runif(no, min = 0, max = 0.1)
df <- data.frame(y = y, z = z, map = NA)
f <- ggplot(data.frame(x = c(0, 1000)), aes(x))
size <- function(x) {5 * sqrt(x)}
f + stat_function(fun = size)
set.seed(19)
SOM <- data.frame(x = c(1:35), w1 = runif(35, min = 0.1, max = 0.9), w2 = runif(35, min = 0.1, max = 0.9), t = factor(1))
ggplot(data = SOM, aes(x = x, y = sqrt(w1^2 + w2^2))) +
geom_line() +
geom_point(aes(color = sqrt(w1^2 + w2^2)), shape = 16, size = 10) +
geom_point(color = "black", shape = 1, size = 10)  +
scale_color_distiller(palette = "Spectral")
count <- 0
count <- count + 1
D <- sqrt((SOM$w1 - df$y[count])^2 + (SOM$w2 - df$z[count])^2)
paste("The node closest to this input observation is", which.min(D), "with a distance D of", format(min(D), digits = 3))
df$map[count] <- which.min(D)
rho <- sqrt((which.min(D) - seq(1, 35))^2)
rho
ggplot(data = data.frame(x = c(1:35), rho = rho), aes(x = x, y = exp(-rho^2/2))) +
geom_line() +
ylab("h(rho)")
w1 <- subset(SOM, t == as.character(count))$w1 + exp(-rho^2/2)*(y[count] - subset(SOM, t == as.character(count))$w1)
w2 <- subset(SOM, t == as.character(count))$w2 + exp(-rho^2/2)*(z[count] - subset(SOM, t == as.character(count))$w2)
SOM <- rbind(SOM, data.frame(x = c(1:35), w1 = w1, w2 = w2, t = factor(count + 1)))
ggplot(data = subset(SOM, t == as.character(count + 1)), aes(x = x, y = sqrt(w1^2 + w2^2))) +
geom_line() +
geom_point(aes(color = sqrt(w1^2 + w2^2)), shape = 16, size = 10) +
geom_point(color = "black", shape = 1, size = 10)  +
scale_color_distiller(palette = "Spectral")
count <- count + 1
D <- sqrt((subset(SOM, t == as.character(count))$w1 - df$y[count])^2 + (subset(SOM, t == as.character(count))$w2 - df$z[count])^2)
paste("The node most closely resembling this observation is", which.min(D), "with a distance D of", format(min(D), digits = 3))
df$map[count] <- which.min(D)
rho <- sqrt((which.min(D) - seq(1, 35))^2)
rho
p <- ggplot(data = SOM, aes(x = x, y = sqrt(w1^2 + w2^2))) +
geom_line(aes(frame = t)) +
geom_point(aes(color = sqrt(w1^2 + w2^2), frame = t), shape = 16, size = 5) +
scale_color_distiller(palette = "Spectral")
p <- ggplotly(p)
p
rm(list = ls())
library(tidyverse) # Easily Install and Load the 'Tidyverse'
library(SOMbrero) # SOM Bound to Realize Euclidean and Relational Outputs
library(plotly) # Create Interactive Web Graphics via 'plotly.js'
library(spdep) # Spatial Dependence: Weighting Schemes, Statistics
pokemon <- read_csv("data/pokemon_gen.csv")
summary(pokemon)
pokemon$Generation <- as.factor(pokemon$Generation)
df <- select(pokemon, Defense, Speed)
ggplot(data = df, aes(x = Defense, y = Speed)) +
geom_point() +
coord_fixed()
set.seed(593)
# run the SOM algorithm
nrows <- 5
ncols <- 5
poke.som <- trainSOM(x.data=df, dimension=c(nrows, ncols), nb.save = 100, radius.type = "letremy", verbose = TRUE)
class(poke.som)
summary(poke.som)
plot(poke.som, what = "energy")
poke.grid <- cell2nb(nrow = nrows, ncol = ncols, type = "rook")
poke.grid <- cell2nb(nrow = nrows, ncol = ncols, type = "rook")
som.grid <- data.frame(x1 = numeric(length(poke.som$backup$prototypes) * length(unlist(poke.grid))))
count <- 0
for(p in 1:length(poke.som$backup$prototypes)){
for(i in 1:(nrows * ncols)){
for(j in 1:length(poke.grid[[i]])){
count <- count + 1
som.grid$x1[count] <- poke.som$backup$prototypes[[p]][i,1]
som.grid$y1[count] <- poke.som$backup$prototypes[[p]][i,2]
som.grid$x2[count] <- poke.som$backup$prototypes[[p]][poke.grid[[i]][j],1]
som.grid$y2[count] <- poke.som$backup$prototypes[[p]][poke.grid[[i]][j],2]
som.grid$backup[count] <- p
}
}
}
som.points <- do.call(rbind.data.frame, poke.som$backup$prototypes)
rownames(som.points) <- c()
som.points$backup <- rep(1:100, each = 25)
p <- ggplot(data = som.points,
aes(x = Defense, y = Speed, frame = backup)) +
geom_segment(data = som.grid,
aes(x = x1, y = y1, xend = x2, yend = y2, frame = backup)) +
geom_point(aes(frame = backup), size = 2) +
coord_equal()
p <- ggplotly(p)
p
som.grid.final <- data.frame(x1 = numeric(length(unlist(poke.grid))))
count <- 0
for(i in 1:(nrows * ncols)){
for(j in 1:length(poke.grid[[i]])){
count <- count + 1
som.grid.final$x1[count] <- poke.som$prototypes[i,1]
som.grid.final$y1[count] <- poke.som$prototypes[i,2]
som.grid.final$x2[count] <- poke.som$prototypes[poke.grid[[i]][j],1]
som.grid.final$y2[count] <- poke.som$prototypes[poke.grid[[i]][j],2]
}
}
som.grid.final <- data.frame(x1 = numeric(length(unlist(poke.grid))))
count <- 0
for(i in 1:(nrows * ncols)){
for(j in 1:length(poke.grid[[i]])){
count <- count + 1
som.grid.final$x1[count] <- poke.som$prototypes[i,1]
som.grid.final$y1[count] <- poke.som$prototypes[i,2]
som.grid.final$x2[count] <- poke.som$prototypes[poke.grid[[i]][j],1]
som.grid.final$y2[count] <- poke.som$prototypes[poke.grid[[i]][j],2]
}
}
ggplot(data = data.frame(node = factor(1:25), poke.som$prototypes),
aes(x = Defense, y = Speed)) +
geom_segment(data = som.grid.final,
aes(x = x1, y = y1, xend = x2, yend = y2)) +
geom_point(aes(color = node), size = 4) +
coord_equal()
ggplot(data = data.frame(node = factor(1:25), poke.som$prototypes),
aes(x = Defense, y = Speed)) +
geom_point(data = data.frame(node = factor(poke.som$clustering), df),
aes(x = Defense, y = Speed, color = node)) +
geom_segment(data = som.grid.final,
aes(x = x1, y = y1, xend = x2, yend = y2),
size = 1) +
geom_point(aes(color = node), size = 4) +
geom_point(shape = 1, size = 4) +
coord_equal()
set.seed(593)
# run the SOM algorithm
nrows <- 5
ncols <- 7
poke.som2 <- trainSOM(x.data=df, dimension=c(nrows, ncols), radius.type = "letremy", verbose = TRUE)
summary(poke.som2)
poke.grid2 <- cell2nb(nrow = nrows, ncol = ncols, type = "rook")
som.grid.final2 <- data.frame(x1 = numeric(length(unlist(poke.grid2))))
count <- 0
for(i in 1:(nrows * ncols)){
for(j in 1:length(poke.grid2[[i]])){
count <- count + 1
som.grid.final2$x1[count] <- poke.som2$prototypes[i,1]
som.grid.final2$y1[count] <- poke.som2$prototypes[i,2]
som.grid.final2$x2[count] <- poke.som2$prototypes[poke.grid2[[i]][j],1]
som.grid.final2$y2[count] <- poke.som2$prototypes[poke.grid2[[i]][j],2]
}
}
ggplot(data = data.frame(node = factor(1:(nrows * ncols)),
poke.som2$prototypes),
aes(x = Defense, y = Speed)) +
geom_point(data = data.frame(node = factor(poke.som2$clustering), df),
aes(x = Defense, y = Speed, color = node)) +
geom_segment(data = som.grid.final2,
aes(x = x1, y = y1, xend = x2, yend = y2),
size = 1) +
geom_point(aes(color = node), size = 4) +
geom_point(shape = 1, size = 4) +
coord_equal()
df <- select(pokemon, HP, Attack, Defense, SpAtk = `Sp. Atk`, SpDef = `Sp. Def`, Speed)
set.seed(593)
# run the SOM algorithm
nrows <- 12
ncols <- 12
poke.som3 <- trainSOM(x.data=df, dimension=c(nrows, ncols), radius.type = "letremy", verbose = TRUE)
summary(poke.som3)
table(poke.som3$clustering)
plot(poke.som3, what = "obs", type = "hitmap")
set.seed(593)
# run the SOM algorithm
nrows <- 8
ncols <- 8
poke.som3 <- trainSOM(x.data=df, dimension=c(nrows, ncols), radius.type = "letremy", verbose = TRUE)
par(mfrow=c(3,2))
plot(poke.som3, what="obs", type="color", variable=1, print.title=TRUE,
main="HP")
plot(poke.som3, what="obs", type="color", variable=2, print.title=TRUE,
main="Attack")
plot(poke.som3, what="obs", type="color", variable=3, print.title=TRUE,
main="Defense")
plot(poke.som3, what="obs", type="color", variable=4, print.title=TRUE,
main="Special Attack")
plot(poke.som3, what="obs", type="color", variable=3, print.title=TRUE,
main="Special Defense")
plot(poke.som3, what="obs", type="color", variable=4, print.title=TRUE,
main="Speed")
plot(poke.som, what="obs", type="barplot", print.title=TRUE)
plot(poke.som3, what="obs", type="meanline", key.loc=c(-2,8), mar=c(0,2,2,0))
plot(poke.som3, what="obs", type="boxplot")
plot(poke.som3, what="add", type="pie", variable=pokemon$Legendary)
poke.sc <- superClass(poke.som3, k=5)
summary(poke.sc)
plot(poke.sc, type="grid", plot.legend=TRUE)
plot(poke.sc, plot.var=FALSE)
rm(list = ls())
library(AppliedPredictiveModeling) # Functions and Data Sets for 'Applied Predictive Modeling'
library(caret) # Classification and Regression Training
library(formattable) # Create 'Formattable' Data Structures
library(kableExtra) # Construct Complex Table with 'kable' and Pipe Syntax
library(knitr) # A General-Purpose Package for Dynamic Report Generation in R
library(plotly) # Create Interactive Web Graphics via 'plotly.js'
library(rpart) # Recursive Partitioning and Regression Trees
library(rpart.plot) # Plot 'rpart' Models: An Enhanced Version of 'plot.rpart'
library(sf) # Simple Features for R
library(spdep) # Spatial Dependence: Weighting Schemes, Statistics
library(SOMbrero) # SOM Bound to Realize Euclidean and Relational Outputs
library(tidyverse) # Easily Install and Load the 'Tidyverse'
library(tmap) # Thematic Maps
data_raw <- read.csv("data/Selected Themes.csv")
convertCSOdata <- function(data, idcol="GEOGDESC"){
results <- data.frame(id = data[[idcol]])
# extract weighted average age.
age_data <- data[,74:108]
mean_ages <- c(0:19, 22, 27, 32, 37, 42, 47, 52, 57, 62, 67, 72, 77, 82, 87)
results$avr_age <- apply(age_data, MARGIN=1, function(x){
#want this function to calculate the average weighted age
# weighted mean age = E(num_people in age bin * average age of bin) / total_people
age <- sum(x[1:length(mean_ages)] * mean_ages) / x[length(x)]
})
# average household size
household_data <- data[, 331:339]
mean_household_size <- c(1:8)
results$avr_household_size <- apply(household_data, 1, function(x){
size <- sum(x[1:length(mean_household_size)] * mean_household_size) / x[length(x)]
})
# Average education level
education_data <- data[,622:634]
mean_education_level <- c(0:10) # the 11th column of data is "not stated" answers - to be removed
results$avr_education_level <- apply(education_data, 1, function(x){
# need to remove the not-stated answers from the total - thus measuring only average on only people who answered questions
education <- sum(x[1:length(mean_education_level)] * mean_education_level) / (x[length(x)] - x[length(x)-1])
})
# Average number of cars per household
car_data <- data[754:758]
num_cars <- c(0:4) # the number of cars per household for each column of temp data
results$avr_num_cars <- apply(car_data, 1, function(x){
# need to remove the not-stated answers from the total - thus measuring only average on only people who answered questions
cars <- sum(x * num_cars) / (sum(x))
})
# Average health reported
health_data <- data[,696:702]
mean_health <- c(5:1) # the 6th column of data is "not stated" answers - to be removed
results$avr_health <- apply(health_data, 1, function(x){
# need to remove the not-stated answers from the total - thus measuring only average on only people who answered questions
health <- sum(x[1:length(mean_health)] * mean_health) / (x[length(x)] - x[length(x)-1])
})
# Percentage rented accomodation = Rented from private landlord / (total - not_stated)
rent_data <- data[, c("T6_3_RPLH", "T6_3_NSH", "T6_3_TH")]
results$rented_percent <- (rent_data[, 1] / (rent_data[, 3] - rent_data[,2])) * 100
# Average unemployment = (looking_for_first_job + lost_job) / (total - disability)
employment_data <- data[, c("T8_1_LFFJT", "T8_1_ULGUPJT", "T8_1_UTWSDT", "T8_1_TT")]
results$unemployment_percent <- ((rowSums(employment_data[, 1:2])) / (employment_data[, 4] - employment_data[,3])) * 100
# Average internet penetration = (broadband + other) / (total - not_stated)
internet_data <- data[, c("T15_3_B", "T15_3_OTH", "T15_3_NS", "T15_3_T")]
results$internet_percent <- ((rowSums(internet_data[, 1:2])) / (internet_data[, 4] - internet_data[,3])) * 100
# Single Percent
# Married Percent
# Divorced Percent
# Widowed Percent
marital_data <- data[, c("T1_2SGLT", "T1_2MART", "T1_2SEPT", "T1_2DIVT", "T1_2WIDT", "T1_2T")]
marital_percents <- data.frame(t(apply(marital_data, 1, function(x) {x[1:5]/x[6]})) * 100)
names(marital_percents) <- c("single_percent", "married_percent", "separated_percent", "divorced_percent", "widow_percent")
results <- cbind(results, marital_percents)
return(results)
}
data <- convertCSOdata(data_raw, idcol = "GEOGDESC")
data <- convertCSOdata(data_raw, idcol = "GEOGDESC")
data_raw <- read.csv("data/Selected Themes.csv")
data <- convertCSOdata(data_raw, idcol = "GEOGDESC")
View(data_raw)
data <- convertCSOdata(data_raw, idcol = "X")
?convertCSOdata
??convertCSOdata
