---
title: "Clustering, profiling and plots"
author: "Antonio Paez & Anastasia Soukhov"
format: html
---

## Setting up table

Lets begin by loading the packages used for this:
```{r message = FALSE}
library(AppliedPredictiveModeling) # Functions and Data Sets for 'Applied Predictive Modeling'
library(caret) # Classification and Regression Training
library(cowplot) # Streamlined Plot Theme and Plot Annotations for 'ggplot2'
library(ggparty) # 'ggplot' Visualizations for the 'partykit' Package
library(party) # A Laboratory for Recursive Partytioning
library(plotly) # Create Interactive Web Graphics via 'plotly.js'
library(rpart) # Recursive Partitioning and Regression Trees
library(rpart.plot) # Plot 'rpart' Models: An Enhanced Version of 'plot.rpart'
library(skimr) # Compact and Flexible Summaries of Data
library(sf) # Simple Features for R
library(SOMbrero) # SOM Bound to Realize Euclidean and Relational Outputs
library(tidyverse) # Easily Install and Load the 'Tidyverse'
library(tmap)
library(here)
library(parsnip)
```

Read od table and the census:
```{r}
load("access_15.rda")
load("HAM_census_21.rda")
```

Loading boundaries for mapping:
```{r}
Community_Boundaries <- st_read("data-raw/boundaries/Community_Boundaries.shp") |> mutate(COMMUNITY_ = ifelse(COMMUNITY_ == "Hamilton", "Hamilton-Central", COMMUNITY_))|> st_transform(crs=4326)
City_Boundary <- st_read("data-raw/boundaries/City_Boundary.shp") |> st_transform(crs=4326)
hydro_p_LakeOntario <- st_read("data-raw/boundaries/hydro_p_LakeOntario.shp") |> st_transform(crs=4326)
ham_bay <- st_read("data-raw/boundaries/Waterbodies.shp") |> st_transform(crs=4326) |> filter(FEATURE_TY == "Lake")
ham_bay_cropped<-st_crop(ham_bay$geometry, Community_Boundaries$geometry)
hydro_p_LakeOntario_cropped<-st_crop(hydro_p_LakeOntario$geometry, Community_Boundaries$geometry)
```

Aggregate by Care Category (dependent, errand, health, and grocery centric):
```{r}
access_15_aggregated <- access_15 |>
  group_by(from_id,
           Care_Category) |>
  summarize(GeoUID = first(GeoUID),
            copp_isc = sum(copp_isc),
            .groups = "drop") |> 
  left_join(HAM_census_21 |> # and dssociate with census data and drop parcels in DAs with 0 population:
              st_drop_geometry(),
            by = "GeoUID")

access_15_aggregated <- access_15_aggregated |> filter(Population >= 0 | !is.na(Population))
```

Calculate total Care Category opportunities by parcel:
```{r}
access_15_aggregated_total <- access_15_aggregated |>
  group_by(from_id) |>
  summarize(tot_copp_isc = sum(copp_isc),
            .groups = "drop")
```

Notice that some parcels have access to zero opportunities:
```{r}
summary(access_15_aggregated_total)
```

How many parcels have zero accessibility (i.e., total number of opportunities is zero):
```{r}
access_15_aggregated_total |>
  filter(tot_copp_isc == 0) |>
  nrow()
```

Join total opportunities to table:
```{r}
access_15_aggregated <- access_15_aggregated |>
  left_join(access_15_aggregated_total,
            by = "from_id")
```

Calculate proportion of opportunities by class (use a zero for the parcels that have accessibility zero):
```{r}
access_15_aggregated <- access_15_aggregated |>
  mutate(prop_copp_isc = ifelse(tot_copp_isc > 0, copp_isc/tot_copp_isc, 0))  
```

Check that the proportions are correct (all should add up to one):
```{r}
access_15_aggregated |>
  group_by(from_id) |>
  summarize(prop = sum(prop_copp_isc)) |>
  filter(round(prop) != 1)
```

Normalize number of opportunities to min-max range:
```{r}
access_15_aggregated <- access_15_aggregated |>
  mutate(copp_isc_norm = ifelse(tot_copp_isc != 0, (copp_isc - min(tot_copp_isc))/(max(tot_copp_isc) - min(tot_copp_isc)), 0))
```

Calculate diversity index:
```{r}
access_15_agg_div <- access_15_aggregated |>
  group_by(from_id) |>
  summarize(div = -sum(prop_copp_isc * log(prop_copp_isc), na.rm = TRUE)/log(4))
```

Pivot od table wider so that each Care Category is a column then retrieve the proportion of opportunities by Care Category:
```{r}
access_15_prop_wide <- access_15_aggregated |>
  select(from_id, Care_Category, prop_copp_isc) |>
  pivot_wider(names_from = "Care_Category", 
              values_from = "prop_copp_isc") |>
  rename_with(-from_id, 
              .fn = ~paste0("prop_",
                            str_replace(.x, "-","_")))
```

Pivot od table wider so that each Care Category is a column and retrieve the normalized number of opportunities:
```{r}
access_15_norm_wide <- access_15_aggregated |>
  select(from_id, Care_Category, copp_isc_norm) |>
  pivot_wider(names_from = "Care_Category", 
              values_from = "copp_isc_norm") |>
  rename_with(-from_id, 
              .fn = ~paste0("norm_", str_replace(.x, "-","_")))
```

Pivot od table wider so that each Care Category is a column and retrieve the total number of opportunities by Category:
```{r}
access_15_total_wide <- access_15_aggregated |>
  select(from_id, Care_Category, copp_isc) |>
  pivot_wider(names_from = "Care_Category", 
              values_from = "copp_isc") |>
  rename_with(-from_id, 
              .fn = ~paste0("total_", str_replace(.x, "-","_")))
```

Summary of these tables:
```{r}
summary(access_15_total_wide)
summary(access_15_norm_wide)
summary(access_15_prop_wide)
summary(access_15_agg_div)
```
Join the tables:
```{r}
access_15_wide <- access_15_total_wide |>
  left_join(access_15_norm_wide,
            by = "from_id") |>
  left_join(access_15_prop_wide,
            by = "from_id") |>
  left_join(access_15_agg_div,
            by = "from_id")
```

Summary of this table:
```{r}
summary(access_15_wide)
```

## Plotting population descriptions, DA

For plotting, create a spatial DA sf object that summarizes these inputs:
```{r}
access_15_DA <- left_join(access_15_wide, 
                          access_15_aggregated |> group_by(from_id) |>
  summarise(GeoUID = first(GeoUID),
            tot_copp_isc = first(tot_copp_isc),
            Population = first(Population),
            LICO = first(`v_CA21_1085: Prevalence of low income based on the Low-income cut-offs, after tax (LICO-AT) (%)`),
            Income_bottom_n = first( `v_CA21_1103: In bottom half of the distribution`),
            Income_top_n = first(`v_CA21_1121: In top half of the distribution`),
            Age_0to14_n = first(`v_CA21_11: 0 to 14 years`),
            Age_15to64_n = first(`v_CA21_68: 15 to 64 years`),   
            Age_65plus_n = first(`v_CA21_251: 65 years and over`),
            One_parent_families_n = first(`v_CA21_507: Total one-parent families`),
            Couple_families_n = first(`v_CA21_500: Total couple families`)),
            by=c("from_id")) |>
  group_by(GeoUID)|>
  summarise(Population = first(Population),
            parcel_count = n(),
            LICO = first(LICO),
            Income_bottom_n = first(Income_bottom_n),
            Income_top_n = first(Income_top_n),
            Age_0to14_n = first(Age_0to14_n),
            Age_15to64_n = first(Age_15to64_n),   
            Age_65plus_n = first(Age_65plus_n),
            One_parent_families_n = first(One_parent_families_n),
            Couple_families_n = first(Couple_families_n),
            
            med_tot_copp_isc = median(tot_copp_isc),
            med_div = median(div),
            med_dep_copp = median(total_Dependent_centric),
            med_err_copp = median(total_Errand_centric),
            med_groc_copp = median(total_Grocery_centric),
            med_health_copp = median(total_Health_centric)) |>
  left_join(HAM_census_21 |> select(c(GeoUID)), by=c("GeoUID")) |> st_as_sf() |> st_make_valid()

access_15_DA <- access_15_DA |> mutate(Populationparcel = Population/parcel_count,
                                       Income_bottom = Income_bottom_n / (Income_bottom_n + Income_top_n),
                                       Age_0to14 = Age_0to14_n / (Age_0to14_n + Age_15to64_n + Age_65plus_n),
                                       One_parent_families = One_parent_families_n / (One_parent_families_n + Couple_families_n))
                                       
access_15_DA$parcel_count |> sum() #a check
```

```{r, eval=FALSE}
parcels_DA_plot <-
 tm_shape(ham_bay, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0) +
  tm_shape(hydro_p_LakeOntario, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0)+
  tm_shape(access_15_DA) +
  tm_polygons("parcel_count",
              border.alpha = 0.2,
              palette = "Reds",style = "quantile", n=4,
              title = "Count of residential parcels",
              legend.is.portrait = TRUE) +
  tm_shape(Community_Boundaries) + tm_polygons(alpha=0)+
  tm_scale_bar(position = c("left", "bottom"), breaks = c(0, 1, 5, 10, 15)) +
  tm_compass(position = c("left", "top"), size=1.0)+
   tm_layout(bg.color = "grey", panel.label.bg.color = "white", legend.position = c("right", "top"), legend.text.size = 0.5,legend.title.size = 0.7,  legend.bg.color = "white", legend.bg.alpha = 0.4)

pop_DA_plot <-
 tm_shape(ham_bay, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0) +
  tm_shape(hydro_p_LakeOntario, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0)+
  tm_shape(access_15_DA) +
  tm_polygons("Population",
              border.alpha = 0.2,
              palette = "Greens", style = "quantile", n=4,
              title = "Population",
              legend.is.portrait = TRUE) +
  tm_shape(Community_Boundaries) + tm_polygons(alpha=0)+
  tm_scale_bar(position = c("left", "bottom"), breaks = c(0, 1, 5, 10, 15)) +
  tm_compass(position = c("left", "top"), size=1.0)+
   tm_layout(bg.color = "grey", panel.label.bg.color = "white", legend.position = c("right", "top"), legend.text.size = 0.5,legend.title.size = 0.7,  legend.bg.color = "white", legend.bg.alpha = 0.4)

poprate_DA_plot <-
 tm_shape(ham_bay, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0) +
  tm_shape(hydro_p_LakeOntario, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0)+
  tm_shape(access_15_DA) +
  tm_polygons("Populationparcel",
              border.alpha = 0.2,
              palette = "Purples", style = "quantile", n=4,
              title = "Population per residential parcel rate",
              legend.is.portrait = TRUE) +
  tm_shape(Community_Boundaries) + tm_polygons(alpha=0)+
  tm_scale_bar(position = c("left", "bottom"), breaks = c(0, 1, 5, 10, 15)) +
  tm_compass(position = c("left", "top"), size=1.0)+
   tm_layout(bg.color = "grey", panel.label.bg.color = "white", legend.position = c("right", "top"), legend.text.size = 0.5,legend.title.size = 0.7,  legend.bg.color = "white", legend.bg.alpha = 0.4)

pop_descriptive_plots_1 <- tmap_arrange(parcels_DA_plot, pop_DA_plot, poprate_DA_plot, nrow=3)
tmap_save(pop_descriptive_plots_1,
          file= file.path(here("figures/pop_descriptive_plots_1.png")) , asp = 1/0.6,
          dpi=300)
```


```{r, eval=FALSE}
INCOME_B_DA_plot <-
 tm_shape(ham_bay, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0) +
  tm_shape(hydro_p_LakeOntario, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0)+
  tm_shape(access_15_DA) +
  tm_polygons("Income_bottom",
              border.alpha = 0.2,
              palette = "Greens", style = "quantile", n=4,
              title = "% hld below AT median income",
              legend.is.portrait = TRUE) +
  tm_shape(Community_Boundaries) + tm_polygons(alpha=0)+
  tm_scale_bar(position = c("left", "bottom"), breaks = c(0, 1, 5, 10, 15)) +
  tm_compass(position = c("left", "top"), size=1.0)+
   tm_layout(bg.color = "grey", panel.label.bg.color = "white", legend.position = c("right", "top"), legend.text.size = 0.5, legend.title.size = 0.7, legend.bg.color = "white", legend.bg.alpha = 0.4)

AGE014_DA_plot <-
 tm_shape(ham_bay, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0) +
  tm_shape(hydro_p_LakeOntario, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0)+
  tm_shape(access_15_DA) +
  tm_polygons("Age_0to14",
              border.alpha = 0.2,
              palette = "Oranges", style = "quantile", n=4,
              title = "% population aged 0 to 14",
              legend.is.portrait = TRUE) +
  tm_shape(Community_Boundaries) + tm_polygons(alpha=0)+
  tm_scale_bar(position = c("left", "bottom"), breaks = c(0, 1, 5, 10, 15)) +
  tm_compass(position = c("left", "top"), size=1.0)+
   tm_layout(bg.color = "grey", panel.label.bg.color = "white", legend.position = c("right", "top"), legend.text.size = 0.5, legend.title.size = 0.7, legend.bg.color = "white", legend.bg.alpha = 0.4)

ONE_PARENT_DA_plot <-
 tm_shape(ham_bay, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0) +
  tm_shape(hydro_p_LakeOntario, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0)+
  tm_shape(access_15_DA) +
  tm_polygons("One_parent_families",
              border.alpha = 0.2,
              palette = "Reds", style = "quantile", n=4,
              title = "% one parent hlds",
              legend.is.portrait = TRUE) +
  tm_shape(Community_Boundaries) + tm_polygons(alpha=0)+
  tm_scale_bar(position = c("left", "bottom"), breaks = c(0, 1, 5, 10, 15)) +
  tm_compass(position = c("left", "top"), size=1.0)+
   tm_layout(bg.color = "grey", panel.label.bg.color = "white", legend.position = c("right", "top"), legend.text.size = 0.5, legend.title.size = 0.7, legend.bg.color = "white", legend.bg.alpha = 0.4)

LICOAT_DA_plot <-
 tm_shape(ham_bay, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0) +
  tm_shape(hydro_p_LakeOntario, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0)+
  tm_shape(access_15_DA) +
  tm_polygons("LICO",
              border.alpha = 0.2,
              palette = "Purples", style = "quantile", n=4,
              title = "Prevalance of household LICO-AT",
              legend.is.portrait = TRUE) +
  tm_shape(Community_Boundaries) + tm_polygons(alpha=0)+
  tm_scale_bar(position = c("left", "bottom"), breaks = c(0, 1, 5, 10, 15)) +
  tm_compass(position = c("left", "top"), size=1.0)+
   tm_layout(bg.color = "grey", panel.label.bg.color = "white", legend.position = c("right", "top"), legend.text.size = 0.5, legend.title.size = 0.7, legend.bg.color = "white", legend.bg.alpha = 0.4)

pop_descriptive_plots_2 <- tmap_arrange(INCOME_B_DA_plot,AGE014_DA_plot, ONE_PARENT_DA_plot, LICOAT_DA_plot, ncol=2)

tmap_save(pop_descriptive_plots_2,
          file= file.path(here("figures/pop_descriptive_plots_2.png")) , asp = 1/1,
          dpi=300)
```

## Plotting accessibility and diversity index, DA

```{r, eval=FALSE}
all_cats_copp_plot <- tm_shape(ham_bay, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0) +
  tm_shape(hydro_p_LakeOntario, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0)+
  tm_shape(access_15_DA) +
  tm_polygons("med_tot_copp_isc",
              border.alpha = 0.2,
              palette = c("darkred", "orangered", "forestgreen", "lightgreen"),
              style = "quantile", n=4,
              #breaks = c(0,5,14,27,108),
              title = "The number of care destinations within a 15 min. walk for a median parcel",
              label = c("[0 to 5) Not caring",
                        "[5 to 14) Somewhat caring",
                        "[14 to 27) Caring",
                        "[27 to 108] Very caring"),  #these are for quantiles, the clusters p50 seem to roughly follows these.
              legend.is.portrait = TRUE) +
  tm_shape(Community_Boundaries) + tm_polygons(alpha=0)+
  tm_scale_bar(position = c("left", "bottom"), breaks = c(0, 1, 5, 10, 15)) +
  tm_compass(position = c("right", "top"), size=1.0)+
  tm_layout(bg.color = "grey",
            panel.label.bg.color = "white",
            panel.label.color = "black",
            legend.outside = TRUE,
            legend.position = c("center", "bottom"),
            legend.outside.position = "bottom",
            legend.outside.size = 0.2,
            legend.width = 12
            # legend.title.size = 0.7,
            # legend.text.size = 0.6
            )
tmap_save(all_cats_copp_plot, file= file.path(here("figures/all_cats_copp_plot.png")), dpi=300)
```

```{r, eval=FALSE}
dep_copp_plot <- tm_shape(ham_bay, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0) +
  tm_shape(hydro_p_LakeOntario, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0)+
  tm_shape(access_15_DA) +
  tm_polygons("med_dep_copp",
              border.alpha = 0.2,
              style = "quantile", n=4,
              palette = "Oranges",
              title = "Dependent-centric",) +
  tm_shape(Community_Boundaries) + tm_polygons(alpha=0)+
  tm_scale_bar(position = c("left", "bottom"), breaks = c(0, 1, 5, 10, 15)) +
  tm_compass(position = c("left", "top"), size=1.0)+
  tm_layout(legend.bg.color = "white", legend.bg.alpha = 0.4,
            bg.color = "grey",
            legend.position = c("right","top"))

health_copp_plot <- tm_shape(ham_bay, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0) +
  tm_shape(hydro_p_LakeOntario, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0)+
  tm_shape(access_15_DA) +
  tm_polygons("med_health_copp",
              border.alpha = 0.2,
              style = "quantile", n=4,
              palette = "Purples",
              title = "Health-centric",) +
  tm_shape(Community_Boundaries) + tm_polygons(alpha=0)+
  tm_scale_bar(position = c("left", "bottom"), breaks = c(0, 1, 5, 10, 15)) +
  tm_compass(position = c("left", "top"), size=1.0)+
  tm_layout(legend.bg.color = "white", legend.bg.alpha = 0.4,
            bg.color = "grey",
            legend.position = c("right","top"))

groc_copp_plot <- tm_shape(ham_bay, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0) +
  tm_shape(hydro_p_LakeOntario, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0)+
  tm_shape(access_15_DA) +
  tm_polygons("med_groc_copp",
              border.alpha = 0.2,
              style = "quantile", n=4,
              palette = "Greens",
              title = "Grocery-centric",) +
  tm_shape(Community_Boundaries) + tm_polygons(alpha=0)+
  tm_scale_bar(position = c("left", "bottom"), breaks = c(0, 1, 5, 10, 15)) +
  tm_compass(position = c("left", "top"), size=1.0)+
  tm_layout(legend.bg.color = "white", legend.bg.alpha = 0.4,
            bg.color = "grey",
            legend.position = c("right","top"))

err_copp_plot <- tm_shape(ham_bay, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0) +
  tm_shape(hydro_p_LakeOntario, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0)+
  tm_shape(access_15_DA) +
  tm_polygons("med_err_copp",
              border.alpha = 0.2,
              style = "quantile", n=4,
              palette = "Reds",
              title = "Errand-centric",) +
  tm_shape(Community_Boundaries) + tm_polygons(alpha=0)+
  tm_scale_bar(position = c("left", "bottom"), breaks = c(0, 1, 5, 10, 15)) +
  tm_compass(position = c("left", "top"), size=1.0)+
  tm_layout(legend.bg.color = "white", legend.bg.alpha = 0.4,
            bg.color = "grey",
            legend.position = c("right","top"))

percats_copp_plot <- tmap_arrange(dep_copp_plot, err_copp_plot, groc_copp_plot, health_copp_plot, nrow=2)

tmap_save(percats_copp_plot, 
          file= file.path(here("figures/percats_copp_plot.png")),
          dpi=300)
```

```{r}
# very caring (mean 4 to 18.6; total p50 46) - very complete (div=0.9; p50 0.90) (Cluster 2)
# caring (mean 2.1 to 9; total p50 18) -  complete (div=0.81; p50 0.82) (Cluster 1)
# somewhat caring (0.2 to 6; total p50 13) - complete (div=0.71; p50 0.74) (Cluster 4)
# somewhat caring (0.2 to 6; total p50 7) - not complete (div=0.36; p50 0.40) (Cluster 3)
# not caring (0 to 4.7; total p50 3) - not complete (div=0.02; p50 0) (Cluster 5)
```

```{r, eval=FALSE}
all_cats_entropy_copp_plot <- tm_shape(ham_bay, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0) +
  tm_shape(hydro_p_LakeOntario, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0)+
  tm_shape(access_15_DA) +
  tm_polygons("med_div",
              border.alpha = 0.2,
              style = "quantile", n=3, #are the quantiles, but are also similar to the clustered profiles
              label = c("[0 to 0.49) Not complete", "[0.49 to 0.85) Complete", "[0.85 to 1] Very complete"),
              palette = "Greys",
              title = "Diversity of care destinations within a 15-minute walk for a median parcel",
              legend.is.portrait = TRUE) +
  tm_shape(Community_Boundaries) + tm_polygons(alpha=0)+
  tm_scale_bar(position = c("left", "bottom"), breaks = c(0, 1, 5, 10, 15)) +
  tm_compass(position = c("right", "top"), size=1.0)+
  tm_layout(bg.color = "grey",
            panel.label.bg.color = "white",
            panel.label.color = "black",
            legend.outside = TRUE,
            legend.position = c("center", "bottom"),
            legend.outside.position = "bottom",
            legend.outside.size = 0.2,
            legend.width = 12)

tmap_save(all_cats_entropy_copp_plot, file= file.path(here("figures/all_cats_entropy_copp_plot.png")), dpi=300)
```

## Creating clusters (from parcels)

Now access_15_wide can be used for the clustering analysis.

Given these normalized attributes, a SOM can be trained using the function `trainSOM` from `SOMbrero`. Only one argument is needed, the input data `x.data`. Other arguments can be assigned by default. In what follows the dimension of the map is given as 5-by-5, and I request that 100 intermediate steps be saved. 
```{r}
set.seed(5935)
# run the SOM algorithm 
nrows <- 5
ncols <- 5
access.som <- trainSOM(x.data = access_15_wide |>
                       # Remove the non-normalized accessibility scores
                       select(-c(from_id, starts_with("total_"))),
                     dimension=c(nrows, ncols),
                     nb.save = 100,
                     radius.type = "letremy",
                     verbose = TRUE)
```

The value of the function (output) is an object of class somRes:
```{r}
class(access.som)
```

The summary reports some attributes of the map:
```{r}
summary(access.som)
```


In this implementation of SOM, the energy is a measure of deformation of the map, when conceptualized as an elastic membrane. The _topographic error_, on the other hand, is the proportion of all data vectors for which first and second best matching units are not adjacent. This measures topology preservation.

In addition, the summary of the SOM includes the results of ANOVA, using the the results of the clustering as the factor. This helps to assess the relevance of each variable to discriminate between clusters.

The `somRes` object includes the following items: 

- clustering: the results of the clustering algorithm, which gives each observation a number that corresponds to their best matching unit (BMU).

- prototypes: the final weights of the cells.

- energy: the final energy.

- backup: a list that includes the prototypes (the weights) at intermediate steps, the steps at which backups were recorded, intermediate clustering results, etc.

Since backups were requested, it is possible to plot the evolution of the training algorithm. For instance, the following plot shows the energy:
```{r}
plot(access.som, 
     what = "energy")
```

The following shows the number of cases assigned to each node:
```{r}
table(access.som$clustering)
```
Which can be visualized by means of a _hitmap_:
```{r}
plot(access.som,
     what = "obs",
     type = "hitmap")
```

# Interpretation of clusters

Interpretation of clusters typically involves descriptive statistics of the clusters. `SOMbrero` implements a number of graphical tools to support interpretation.

The first example is a heatmap of the variables in clusters:
```{r}
par(mfrow=c(3,2))
plot(access.som, 
     what = "obs", 
     type = "color", 
     variable = 1, 
     show.names=TRUE, 
     main="norm_Dependent_centric")
plot(access.som, 
     what = "obs", 
     type = "color", 
     variable = 2, 
     show.names = TRUE, 
     main = "norm_Errand_centric")
plot(access.som, 
     what = "obs", 
     type = "color", 
     variable = 3,
     show.names = TRUE, 
     main="norm_Grocery_centric")
plot(access.som, 
     what="obs", 
     type="color", 
     variable=4, 
     show.names = TRUE, 
     main="norm_Health_centric")
plot(access.som, 
     what="obs", 
     type="color",
     variable = 9, 
     show.names = TRUE, 
     main="Diversity")
```

The lower right corner of the map concentrates monsters has low levels of all variables. The high concentration of all variables is found in the upper left corner. Two additional way of visualizing the characteristics of the clusters are as follows.

This creates barplots:
```{r}
plot(access.som, 
     what = "obs", 
     type="barplot", 
     show.names=TRUE)
```

And this creates mean lines:
```{r}
plot(access.som, 
     what="obs", 
     type="meanline", 
     key.loc=c(-2,8), 
     mar=c(0,2,2,0))
```

And of course, we would like to know how much dispersion there is within the clusters, something that can be explored by means of boxplots:
```{r}
plot(access.som, 
     what="obs", 
     type="boxplot")
```

Super clusters:
```{r}
access.sc <- superClass(access.som,
                        k = 5)
summary(access.sc)
```
The combined dendogram and grid-map of the super-clusters. Turned off the variance explained plot:
```{r, eval=FALSE}
png(file= file.path(here("figures/access_sc_plot_1.png")), width= 2404, height= 1600, units="px",  res=300)
plot(access.sc, 
     type= c("dendrogram"),
     plot.var = FALSE,
     show.names = TRUE,
     main = " ",
     ylab="Dissimilarity Index",
     xlab= " ")
dev.off()
```


```{r, eval=FALSE}
png(file= file.path(here("figures/access_sc_plot_2.png")), width= 2404, height= 1600, units="px",  res=300)
plot(access.sc,
     type = "grid", 
     plot.var = FALSE,
     main = " ",
     plot.legend = TRUE)
dev.off()
```


## Profile the superclusters

Once that clusters have been obtained, it is interesting to profile the results. By profiling the results, we can derive insights as to the (hopefully) distinctive characteristics of the clusters. For instance, is Cluster 1 mostly composed of young people? People with internet access? 

Explore the results. First append the results of the cluster and super cluster analysis to dataframe:
```{r}
access_15_wide$cluster <- access.som$clustering
access_15_wide$scluster <- access.sc$cluster[access.som$clustering]
```

Select four of the features with the greatest discriminatory power, and do a feature plot (from package `caret`):
```{r fig.width=16}
# transparentTheme(trans = .4)
# featurePlot(x = data.frame(access_15_wide$div, 
#                            access_15_wide$Dependent_centric_norm, 
#                            access_15_wide$Errand_centric_norm,
#                            access_15_wide$Grocery_centric_norm,
#                            access_15_wide$Health_centric_norm), 
#             y = as.factor(access_15_wide$scluster), 
#             plot = "pairs",
#             ## Add a key at the top
#             auto.key = list(columns = 8))
```

Descriptive statistics of superclusters.

```{r}
access_15_wide |>
  select(scluster, starts_with("total_"), div) |>
  group_by(scluster) |>
  skim()
```

## Profiling the super clusters

One possibility is to analyze the results of the clustering algorithm by means of a classification technique. This is illustrated here by means of a decision tree. A decision tree is a supervised learning technique, which in this case can use the results of the clustering algorithm as labels, and the input variables as features. If the clustering algorithm performed well, class membership must be relatively homogeneous. Since a decision tree 

Select data for classification:
```{r}
df <- access_15_wide |>
  select(-c(cluster,
            starts_with("prop"), 
            starts_with("norm"))) |>
  rename(Dependent = total_Dependent_centric,
         Grocery = total_Grocery_centric,
         Errand = total_Errand_centric,
         Health = total_Health_centric) |>
  mutate(scluster = factor(scluster),
         div = round(div, digits = 3))

df <- df |> 
  mutate(Total_copp = Dependent + Grocery + Errand + Health)
```

Train a decision tree using the data:
```{r}
classmod.som <- rpart(data = df,
                      formula = scluster ~ (Dependent + Grocery + Errand + Health + div))

# Predict the labels and add them to the dataset
predicted_labels <- predict(classmod.som, df) |> as.data.frame()

df$SC1 <- predicted_labels$`1`
df$SC2 <- predicted_labels$`2`
df$SC3 <- predicted_labels$`3`
df$SC4 <- predicted_labels$`4`
df$SC5 <- predicted_labels$`5`

# df <- df |> mutate(max_label_val = pmax(predicted_labels$`1`, predicted_labels$`2`, predicted_labels$`3`, predicted_labels$`4`, predicted_labels$`5`),
#                    max_label = case_when(max_label_val == predicted_labels$`1` ~ "SC1",
#                                          max_label_val == predicted_labels$`2` ~ "SC2",
#                                          max_label_val == predicted_labels$`3` ~ "SC3",
#                                          max_label_val == predicted_labels$`4` ~ "SC4",
#                                          max_label_val == predicted_labels$`5` ~ "SC5"))


df_DA <- df |> left_join(access_15 |> dplyr::select(c("from_id","GeoUID")), by = "from_id") |> 
  group_by(GeoUID) |> 
  summarise(
    SC1 = median(SC1),
    SC2 = median(SC2),
    SC3 = median(SC3),
    SC4 = median(SC4),
    SC5 = median(SC5),
    max_label_val = pmax(SC1, SC2, SC3, SC4, SC5),
            med_tot_copp_isc = median(Total_copp),
            med_div = median(div),
            med_dep_copp = median(Dependent),
            med_err_copp = median(Errand),
            med_groc_copp = median(Grocery),
            med_health_copp = median(Health)) |>
  mutate(max_label = case_when(max_label_val == SC1 ~ "b. Caring - complete (SC1)",
                               max_label_val == SC2 ~ "a. Very caring - very complete (SC2)",
                               max_label_val == SC3 ~ "d. Somewhat caring - not complete (SC3)",
                               max_label_val == SC4 ~ "c. Somewhat caring - complete (SC4)",
                               max_label_val == SC5 ~ "d. not caring - not complete (SC5)")) |>
  left_join(HAM_census_21 |> select(c(GeoUID)), by=c("GeoUID")) |> st_as_sf() |> st_make_valid() 
```
```{r, eval=FALSE}
total_copp_plot <- tm_shape(ham_bay, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0) +
  tm_shape(hydro_p_LakeOntario, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0)+
  tm_shape(df_DA) +
  tm_polygons("med_tot_copp_isc",
              border.alpha = 0.2,
              style = "quantile", n=4,
              palette = "Purples",
              title = "Total access to care destinations",) +
  tm_shape(Community_Boundaries) + tm_polygons(alpha=0)+
  tm_scale_bar(position = c("left", "bottom"), breaks = c(0, 1, 5, 10, 15)) +
  tm_compass(position = c("left", "top"), size=1.0)+
  tm_layout(legend.bg.color = "white", legend.bg.alpha = 0.4,
            bg.color = "grey",
            legend.position = c("right","top"))

SClabel_copp_plot <- tm_shape(ham_bay, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0) +
  tm_shape(hydro_p_LakeOntario, bbox=Community_Boundaries) + tm_polygons(col="skyblue", border.alpha = 0)+
  tm_shape(df_DA) +
  tm_polygons("max_label",
              border.alpha = 0.2,
              palette = c("darkolivegreen","red", "dodgerblue", "darkorchid","darkgreen"),
              labels = (c("Very caring - very complete (SC2)","Caring - Complete (SC1)",
              "Somewhat caring - complete (SC4)","Somewhat caring - somewhat complete (SC5)", 
              "Somewhat caring - somewhat complete (SC3)")),
              title = "Prevelant supercluster") +
  tm_shape(Community_Boundaries) + tm_polygons(alpha=0)+
  tm_scale_bar(position = c("left", "bottom"), breaks = c(0, 1, 5, 10, 15)) +
  tm_compass(position = c("left", "top"), size=1.0)+
  tm_layout(legend.bg.color = "white", legend.bg.alpha = 0.4,
            bg.color = "grey",
            legend.position = c("right","top"))
SClabel_copp_plot
SCLab_and_total_copp_plot <- tmap_arrange(SClabel_copp_plot, total_copp_plot, nrow=2)

tmap_save(SCLab_and_total_copp_plot, 
          file= file.path(here("figures/SCLab_and_total_copp_plot.png")),
          dpi=300)
```

Visualize the decision tree:
```{r}
rpart.plot(classmod.som, cex = 0.5, type = 0, varlen = 8)
```

This does not look too pretty. Try ggparty, but first convert the rpart object to a party object:
```{r}
classmod.sompar <- as.party(classmod.som)
```

Autoplot as ggplot:
```{r}
autoplot(classmod.sompar)
```

Frequency of parcels in the super clusters:
```{r}
freq_sc <- ggplot(access_15_wide |> 
         mutate(scluster = factor(scluster))) +
  geom_bar(aes(x = "", 
               group = scluster, 
               fill = scluster)) +
  scale_fill_discrete(name = "Supercluster") #+
  #theme_void() +
  #guides(fill = guide_legend(nrow = 1)) +
  #theme(legend.position = "bottom")

freq_sc
```

Extract the legend:
```{r}
legd <- cowplot::get_legend(freq_sc)

legd
```

Make a prettier plot:
```{r}
party_plot <- ggparty(classmod.sompar) +
  geom_edge() +
  geom_edge_label(size = 1.6) +
  geom_node_label(aes(label = splitvar),
                  id = "inner", 
                  size = 2, nudge_y = -0.022) +
  # pass list to gglist containing all ggplot components we want to plot for each
  # (default: terminal) node
  geom_node_plot(gglist = list(geom_bar(aes(x = "", fill = scluster),
                                        position = position_fill()),
                               xlab(""),
                               ylab(""),
                               theme_void(),
                               theme(axis.text = element_blank())))
party_plot
```

Plot the tree:
```{r}
png(file= file.path(here("figures/decision_tree_profiles_sc.png")),width= 2404, height= 1600, units="px",  res=300)
plot_grid(party_plot, legd, nrow = 1, rel_widths = c(1, 0.2))
dev.off()
```

Cluster 6 is high in suckitude: low in diversity, with 4.6 Dependent Centric destinations on average, and typically no other destinations: zero Errand centric destinations, and only about 3.5% of parcels have access to Grocery-centric destinations.
```{r}
access_15_wide |>
  select(scluster, starts_with("total_"), div) |>
  rename_with(.fn = ~str_replace(.x, "total_", "")) |>
  filter(scluster == 1) |>
  skim()
```

What I've deduced from these superclusters:

very caring (mean 4 to 18.6; total p50 46) - very complete (div=0.9; p50 0.90) (Cluster 2)
caring (mean 2.1 to 9; total p50 18) - complete (div=0.81; p50 0.82) (Cluster 1)
somewhat caring (0.2 to 6; total p50 13) - complete (div=0.71; p50 0.74) (Cluster 4)
somewhat caring (0.2 to 6; total p50 7) - not complete (div=0.36; p50 0.40) (Cluster 3)
not caring (0 to 4.7; total p50 3) - not complete (div=0.02; p50 0) (Cluster 5)

## Demographic profile of clusters

Select data for classification:
```{r}
df <- access_15_wide |>
  transmute(scluster = factor(scluster),
            Income_bottom = `v_CA21_1103: In bottom half of the distribution`/(`v_CA21_1103: In bottom half of the distribution` + `v_CA21_1121: In top half of the distribution`),
            LICO = `v_CA21_1085: Prevalence of low income based on the Low-income cut-offs, after tax (LICO-AT) (%)`,
            Avg_numb_of_kids = `v_CA21_498: Average number of children in census families with children`,
            Not_in_labforce = `v_CA21_6504: Not in the labour force`/(`v_CA21_6498: Employed` + `v_CA21_6501: Unemployed` + `v_CA21_6504: Not in the labour force`),
            Income_gini = `v_CA21_1142: Gini index on adjusted household after-tax income`,
            Vis_minority = `v_CA21_4875: Total visible minority population`/ (`v_CA21_4914: Not a visible minority`+ `v_CA21_4875: Total visible minority population`),
            Age_0to14 =(`v_CA21_11: 0 to 14 years`) / (`v_CA21_11: 0 to 14 years` + `v_CA21_68: 15 to 64 years` + `v_CA21_251: 65 years and over`),
            One_parent_families = `v_CA21_507: Total one-parent families` / (`v_CA21_507: Total one-parent families` + `v_CA21_500: Total couple families`),
            walk_towork =  `v_CA21_7647: Walked` / (`v_CA21_7647: Walked` + `v_CA21_7635: Car, truck or van` + `v_CA21_7644: Public transit` + `v_CA21_7650: Bicycle` + `v_CA21_7653: Other method` ),
            Owner_hld_CHN = `v_CA21_4308: % in core housing need (57)`,
            Hld_ownership = `v_CA21_4306: % of owner households with a mortgage (58)`,
            Tenant_subsi_hld = `v_CA21_4314: % of tenant households in subsidized housing (61)`,
            Tenant_hld_CHH =`v_CA21_4316: % in core housing need (57)`,
            Population,
            Low_or_no_deg = (`v_CA21_5868: No certificate, diploma or degree` + `v_CA21_5871: High (secondary) school diploma or equivalency certificate`) / (`v_CA21_5868: No certificate, diploma or degree` + `v_CA21_5871: High (secondary) school diploma or equivalency certificate` + `v_CA21_5874: Postsecondary certificate, diploma or degree`)
            )

# examining correlations
cor(df |> select(-c("scluster")), use = "complete.obs")

#Train a decision tree using the data:
classdemo.som <- rpart(data = df,
                      formula = scluster ~ (Income_bottom + Age_0to14 + One_parent_families + Vis_minority + Not_in_labforce+ Income_gini+walk_towork+Owner_hld_CHN+Hld_ownership+Tenant_subsi_hld+Tenant_hld_CHH),
                      weights = Population
                      )
# # Visualize the decision tree:
# rpart.plot(classdemo.som, cex = 0.5, type = 0, varlen = 8)
```

```{r}
# convert the rpart object to a party object:
classdemo.sompar <- as.party(classdemo.som)

#Make a prettier plot:
party_plot <- ggparty(classdemo.sompar) +
  geom_edge() +
  #geom_edge_label(size = 1.8) +
  geom_edge_label(mapping = aes(label = paste(substr(breaks_label, start = 1, stop = 15))), size = 3.5) +
  geom_node_splitvar(id = "inner", size = 4) +
  #geom_edge_label(mapping = aes(label = prettyNum(breaks_label, digits = 1)), size = 1.8) +

  # # pass list to gglist containing all ggplot components we want to plot for each
  # # (default: terminal) node
  geom_node_plot(gglist = list(geom_bar(aes(x = "", fill = scluster),
                                        position = position_fill()),
                               xlab(""),
                               ylab(""),
                               theme_void(),
                               theme(axis.text = element_blank())))
legd <- cowplot::get_legend(freq_sc)
```

```{r}
#plot and save
png(file= file.path(here("figures/access_sc_profiles.png")),width= 2404, height= 1600, units="px",  res=300)
plot_grid(party_plot, legd, nrow = 1, rel_widths = c(1, 0.2))
dev.off()
```

This is interesting! So for parcels with less than 45% of bottom-income people (richer) -- parcels with higher proportion of 1 parent households (13% and above) are more likely to have bad care/incomplete access (c3) than _really_ bad care/very incomplete access (c5). 

For parcels with higher than 45% of bottom-income (poorer), those with high a high proportion of children (age 0 to 14) are likely to have bad care/incomplete acces (c3). But those with a lower proportion of children - especially 9.8% LICO and above are going to have _super high_ care/complete (c1) or under 9.8% LICO will have _high_ care/complete (c2)
For less than 63%, it's a different story. If between 45% and 63%, they are described by cluster 1 (caring and complete). 

