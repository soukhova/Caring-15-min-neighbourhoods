library(cancensus)
library(sf)
library(leaflet)
library(r5r)
library(dplyr)
library(purrr)
# increase Java memory
options(java.parameters = "-Xmx6G")
#changing my time zone to Toronto's time zone
Sys.setenv(TZ='EDT')
#load("HAM_census_21.rda")
Community_Boundaries <- read_sf("data-raw/Community_Boundaries.shp") |> st_transform(st_crs(HAM_census_21))
load("HAM_census_21.rda")
Community_Boundaries <- read_sf("data-raw/Community_Boundaries.shp") |> st_transform(st_crs(HAM_census_21))
#some DAs are oddly shaped, such that their centroids are outside of their surface. here we create a function if the polygon has a centroid that is inside the polygon, use that, otherwise, find a point within the polygon. (From: https://stackoverflow.com/questions/52522872/r-sf-package-centroid-within-polygon)
st_centroid_within_poly <- function (poly) {
# check if centroid is in polygon
centroid <- poly %>% st_centroid()
in_poly <- st_within(centroid, poly, sparse = F)[[1]]
# if it is, return that centroid
if (in_poly) return(centroid)
# if not, calculate a point on the surface and return that
centroid_in_poly <- st_point_on_surface(poly)
return(centroid_in_poly)
}
orig_sf <- HAM_census_21 |> st_intersection(City_Boundary |> filter(COMMUNITY_ == "Dundas" | COMMUNITY_ == "Flamborough")) |>
mutate(lon = map_dbl(geometry, ~st_centroid_within_poly(.x)[[1]]),
lat = map_dbl(geometry, ~st_centroid_within_poly(.x)[[2]]))
orig_sf <- HAM_census_21 |> st_intersection(Community_Boundaries |> filter(COMMUNITY_ == "Dundas" | COMMUNITY_ == "Flamborough")) |>
mutate(lon = map_dbl(geometry, ~st_centroid_within_poly(.x)[[1]]),
lat = map_dbl(geometry, ~st_centroid_within_poly(.x)[[2]]))
orig <- orig_sf %>%
st_drop_geometry() %>%
transmute(id = GeoUID,
lon,
lat)
#takesa few minutes
r5_HAM <- setup_r5(data_path = r5_path, verbose = TRUE)
# the r5r package requires Java Development Kit version 11, which can be downloaded from https://www.oracle.com/java/technologies/javase-jdk11-downloads.html . See the direction given in the r5r installation here (https://ipeagit.github.io/r5r/articles/r5r.html)
dir.create("./data-raw/tt") #create a folder, if it already exists - this function does nothing
r5_path <- file.path("./data-raw/tt")
list.files(r5_path)
# the r5r package requires Java Development Kit version 11, which can be downloaded from https://www.oracle.com/java/technologies/javase-jdk11-downloads.html . See the direction given in the r5r installation here (https://ipeagit.github.io/r5r/articles/r5r.html)
dir.create("./data-raw/tt") #create a folder, if it already exists - this function does nothing
r5_path <- file.path("./data-raw/tt")
list.files(r5_path)
#takesa few minutes
r5_HAM <- setup_r5(data_path = r5_path, verbose = TRUE)
library(concaveman) #dundas works. Flamborough, hamilton, ancaster, stoney creek and Glanbrook DO NOT.
iso15_walk <- r5r::isochrone(r5r_core = r5_HAM,
origins = orig,
mode = "WALK",
sample_size = 0.2,
max_trip_duration = 15,
cutoffs = 15)
orig_sf <- HAM_census_21 |> st_intersection(Community_Boundaries |> filter(COMMUNITY_ == "Dundas")) |>
mutate(lon = map_dbl(geometry, ~st_centroid_within_poly(.x)[[1]]),
lat = map_dbl(geometry, ~st_centroid_within_poly(.x)[[2]]))
orig <- orig_sf %>%
st_drop_geometry() %>%
transmute(id = GeoUID,
lon,
lat)
iso15_walk <- r5r::isochrone(r5r_core = r5_HAM,
origins = orig,
mode = "WALK",
sample_size = 0.2,
max_trip_duration = 15,
cutoffs = 15)
# Mapping DAs
leaflet() |>
addTiles() |>
addPolygons(data = iso15_walk)
iso15_walk <- r5r::isochrone(r5r_core = r5_HAM,
origins = orig,
mode = "WALK",
sample_size = 1,
max_trip_duration = 15,
cutoffs = c(0,15))
# Mapping DAs
leaflet() |>
addTiles() |>
addPolygons(data = iso15_walk)
# addPolygons(data= HAM_census_21 |> filter(Households != 0)) |>
# addMarkers(data = st_as_sf(orig_sf |> st_drop_geometry(), coords = c("lon", "lat"),
#                crs = 4326, agr = "constant"))
# Mapping DAs
leaflet() |>
addTiles() |>
addPolygons(data = orig_sf)
# Mapping DAs
leaflet() |>
addTiles() |>
addPolygons(data = HAM_census_21)
iso15_walk <- r5r::isochrone(r5r_core = r5_HAM,
origins = orig,
mode = "WALK",
sample_size = 1,
max_trip_duration = 30,
cutoffs = c(0,30))
# Mapping DAs
leaflet() |>
addTiles() |>
addPolygons(data = iso15_walk)
# Mapping DAs
leaflet() |>
addTiles() |>
addPolygons(data = orig_sf)
# Mapping DAs
leaflet() |>
addTiles() |>
addPolygons(data = Community_Boundaries)
# Mapping DAs
leaflet() |>
addTiles() |>
addPolygons(data = orig_sf)
# Mapping DAs
leaflet() |>
addTiles() |>
addPolygons(data = Community_Boundaries)
# Mapping DAs
leaflet() |>
addTiles() |>
addPolygons(data = orig_sf)
iso15_walk <- r5r::isochrone(r5r_core = r5_HAM,
origins = orig,
mode = "WALK",
sample_size = 1,
max_trip_duration = 15,
cutoffs = c(0,15))
# Mapping DAs
leaflet() |>
addTiles() |>
addPolygons(data = iso15_walk)
# Mapping DAs
leaflet() |>
addTiles() |>
addPolygons(data = iso15_walk) |>
# addPolygons(data= HAM_census_21 |> filter(Households != 0)) |>
addMarkers(data = st_as_sf(orig_sf |> st_drop_geometry(), coords = c("lon", "lat"), crs = 4326, agr = "constant"))
# Mapping DAs
leaflet() |>
addTiles() |>
addPolygons(data = iso15_walk |> filter(id == 35250030)) |>
# addPolygons(data= HAM_census_21 |> filter(Households != 0)) |>
addMarkers(data = st_as_sf(orig_sf |> st_drop_geometry() |> filter(GeoUID == 35250030), coords = c("lon", "lat"), crs = 4326, agr = "constant"))
# Mapping DAs
leaflet() |>
addTiles() |>
addPolygons(data = iso15_walk |> filter(id == 35250056)) |>
# addPolygons(data= HAM_census_21 |> filter(Households != 0)) |>
addMarkers(data = st_as_sf(orig_sf |> st_drop_geometry() |> filter(GeoUID == 35250056), coords = c("lon", "lat"), crs = 4326, agr = "constant"))
orig_sf <- HAM_census_21 |> st_intersection(Community_Boundaries |> filter(COMMUNITY_ == "Dundas")) |>
mutate(lon = map_dbl(geometry, ~st_centroid_within_poly(.x)[[1]]),
lat = map_dbl(geometry, ~st_centroid_within_poly(.x)[[2]]))
View(orig_sf)
